#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

const projects = ["frontend", "backend"];
const packages = new Map();
const warnings = [];

const normalizeLicense = (license) => {
  if (!license) return "UNKNOWN";
  if (typeof license === "string") return license;
  if (Array.isArray(license)) {
    const values = license.map((entry) =>
      typeof entry === "string" ? entry : entry?.type || "UNKNOWN",
    );
    return values.join(", ");
  }
  if (typeof license === "object") return license.type || "UNKNOWN";
  return "UNKNOWN";
};

const normalizeRepository = (repo) => {
  if (!repo) return "";
  if (typeof repo === "string") return repo;
  if (typeof repo === "object") return repo.url || "";
  return "";
};

const escapeTableValue = (value) =>
  String(value ?? "")
    .replaceAll("|", "\\|")
    .replaceAll("\n", " ")
    .trim();

for (const project of projects) {
  const pnpmDir = path.join(repoRoot, project, "node_modules", ".pnpm");
  if (!fs.existsSync(pnpmDir)) {
    warnings.push(`Missing ${project}/node_modules/.pnpm (run pnpm install).`);
    continue;
  }

  const entries = fs.readdirSync(pnpmDir, { withFileTypes: true });
  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    if (entry.name.startsWith(".")) continue;

    const base = entry.name.split("_")[0];
    const atIndex = base.lastIndexOf("@");
    if (atIndex <= 0) continue;

    const nameEncoded = base.slice(0, atIndex);
    const fallbackVersion = base.slice(atIndex + 1);
    const packageName = nameEncoded.replaceAll("+", "/");
    const packageJsonPath = path.join(
      pnpmDir,
      entry.name,
      "node_modules",
      ...packageName.split("/"),
      "package.json",
    );

    if (!fs.existsSync(packageJsonPath)) {
      warnings.push(
        `Missing package.json for ${packageName} in ${project} (expected at ${packageJsonPath}).`,
      );
      continue;
    }

    let packageJson;
    try {
      const fileContents = fs.readFileSync(packageJsonPath, "utf8");
      packageJson = JSON.parse(fileContents);
    } catch (error) {
      warnings.push(
        `Failed to read or parse package.json for ${packageName}@${fallbackVersion} at ${packageJsonPath}: ${error?.message || error}`,
      );
      continue;
    }
    const name = packageJson.name || packageName;
    const version = packageJson.version || fallbackVersion;
    const license = normalizeLicense(packageJson.license);
    const repository = normalizeRepository(packageJson.repository);
    const key = `${name}@${version}`;

    if (!packages.has(key)) {
      packages.set(key, { name, version, license, repository });
    }
  }
}

const sortedPackages = Array.from(packages.values()).sort((a, b) =>
  a.name.localeCompare(b.name),
);

const lines = [
  "# Third-Party Notices",
  "",
  "This file lists third-party packages detected in `frontend/node_modules` and `backend/node_modules`.",
  "",
  "Generated by `node scripts/generate-third-party-notices.mjs`.",
  "",
  "| Package | Version | License | Repository |",
  "| --- | --- | --- | --- |",
];

for (const entry of sortedPackages) {
  lines.push(
    `| ${escapeTableValue(entry.name)} | ${escapeTableValue(
      entry.version,
    )} | ${escapeTableValue(entry.license)} | ${escapeTableValue(
      entry.repository,
    )} |`,
  );
}

if (warnings.length) {
  lines.push("", "## Notes", "");
  for (const warning of warnings) {
    lines.push(`- ${warning}`);
  }
}

const outputPath = path.join(repoRoot, "THIRD_PARTY_NOTICES.md");
fs.writeFileSync(outputPath, lines.join("\n") + "\n", "utf8");
console.log(`Wrote ${outputPath}`);
